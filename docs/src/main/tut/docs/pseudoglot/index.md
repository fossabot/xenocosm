---
layout: docs
title: Pseudoglot
---
# Building a Name Generator with Pseudoglot

For our purposes, a name generator is a program that will generate syllables
which should appear to more-or-less "belong" together. We do that in Pseudoglot
by using a common set of phonotactics, which are strategies for generating
clusters of phones (the smallest unit of sound).

## Setup our imports and create the RNG

Pseudoglot uses the `spire.random` package for generating `Dist[T]` instances,
which in turn define how random components of our name generator are created. So
the first thing we need is a (pseudo-)random number generator. We'll just use
the default one here, but Spire lets you choose from an assortment.

```tut
import cats.implicits._
import spire.random.Dist
import pseudoglot.data._
import pseudoglot.implicits._

val rng = spire.random.Generator.rng
```

## Create a random Phonology

Next up, we'll create a `Phonology` which encapsulates syllable creation. All
syllables generated by an instance of `Phonology` should be consistent with its
`Phone` catalog and `PhonotacticRule`s.

```tut
val phonology = Phonology.dist(rng)
```

## Provide a transcription

Pseudoglot provides an instance of `Transcription` for the International
Phonetic Alphabet. However, one often needs a romanization (phonemic
transcription) of `Phones` into a non-academic orthography for practical use. As
such, pseudoglot also provides a way of generating a `Transcription` with
`pseudoglot.Romanization.dist`.

```tut
implicit val xlit = pseudoglot.Romanization.dist(rng)
```

## Transcribe the phonology

Now with all the bookkeeping out of the way, lets see what we have. First, we'll
generate an alphabet (of sorts), which simply transcribes each `Phone` in our
`Phonology` using the above `Transcription`. Since our `USEnglish` transcription
doesn't provide a mapping for every possible vowel and consonant, the
`Transcription` will transparently use a distance method to find the closest
mapping available. If there is nothing close, it will transcribe the `Phone` as
an underscore (`_`).

```tut
import cats.data.NonEmptyList

println(phonology.pulmonics.map(p => NonEmptyList.one(p).transcribe).toList.mkString(", "))
println(phonology.vowels.map(v => NonEmptyList.one(v).transcribe).toList.mkString(", "))
```

## Get some monosyllables from the Phonology

Next, we'll use our `Phonology` to generate some monosyllabic "words".

```tut
val syllableGen = phonology.syllable.map(_.transcribe)
syllableGen.pack(10).apply(rng).foreach(println)
```

## The Morphology

Next, we'll create a `Morphology` from our `Phonology` to generate morphemes.

```tut
val morphemeGen = Morphology(phonology).morpheme.map(_.transcribe)
morphemeGen.pack(10).apply(rng).foreach(println)
```

## What's in a name

Now that we can generate "words" of varying length, let's combine them to make
our names. We'll replace the underscores with the more trendy apostrophe and
provide capitalization as well.

```tut
val nameGen = for {
  s1 <- morphemeGen.map(_.capitalize)
  s2 <- morphemeGen.map(_.capitalize)
  s3 <- morphemeGen.map(_.capitalize)
  s4 <- morphemeGen.map(_.capitalize)
  s1_2 = List(s1, s2).mkString(" ")
  s2_1 = List(s2, s1).mkString(" ")
  s1_3 = List(s1, s3).mkString(" ")
  name <- Dist.oneOf(s1, s2, s1_2, s2_1, s1_3, s3, s4)
} yield name.map({
  case '_' => '\''
  case x => x
})

nameGen.pack(20).apply(rng).foreach(println)
```

---
layout: docs
title: Pseudoglot
---
# Building a Name Generator with Pseudoglot

For our purposes, a name generator is a program that will generate syllables
which should appear to more-or-less "belong" together. We do that in Pseudoglot
by using a common set of phonotactics, which are strategies for generating
clusters of phones (the smallest unit of sound).

## Setup our imports and create the RNG

Pseudoglot uses the `spire.random` package for generating `Dist[T]` instances,
which in turn define how random components of our name generator are created. So
the first thing we need is a (pseudo-)random number generator. We'll just use
the default one here, but Spire lets you choose from an assortment.

```tut
import cats.implicits._
import spire.random.Dist
import pseudoglot.data._
import pseudoglot.implicits._
import Magic.default

val rng = spire.random.Generator.rng
```

## Create a random Prosody

Next up, we'll create a `Prosody` which is an object that encapsulates syllable
creation using a provided `Phonology`. All syllables generated by an instance of
`Prosody` should be consistent with its `Phone` catalog and `PhonotacticRule`s.

```tut
val prosody = Prosody.dist.apply(rng)
```

## Provide a transcription

Pseudoglot does not provide an instance of `Transcription` other than for the
International Phonetic Alphabet. However, here is a simple instance of
`Transcription` which encodes the American English tables and charts found in
_The Handbook of the International Phonetic Association_, p.41-44.

```tut
object USEnglish {

  val pulmonics:Map[Pulmonic, String] = Map(
    Pulmonic(Voiceless, Bilabial, Plosive) -> "p",
    Pulmonic(Voiced, Bilabial, Plosive) -> "b",
    Pulmonic(Voiced, Bilabial, Nasal) -> "m",
    Pulmonic(Voiceless, LabioDental, Fricative) -> "f",
    Pulmonic(Voiced, LabioDental, Fricative) -> "v",
    Pulmonic(Voiceless, Dental, Fricative) -> "th",
    Pulmonic(Voiced, Dental, Fricative) -> "th",
    Pulmonic(Voiceless, Alveolar, Plosive) -> "t",
    Pulmonic(Voiced, Alveolar, Plosive) -> "d",
    Pulmonic(Voiced, Alveolar, Nasal) -> "n",
    Pulmonic(Voiceless, Alveolar, Fricative) -> "s",
    Pulmonic(Voiced, Alveolar, Fricative) -> "z",
    Pulmonic(Voiced, Alveolar, Approximant) -> "r",
    Pulmonic(Voiced, Alveolar, LateralApproximant) -> "l",
    Pulmonic(Voiceless, PostAlveolar, Fricative) -> "sh",
    Pulmonic(Voiced, PostAlveolar, Fricative) -> "zh",
    Pulmonic(Voiced, Palatal, Approximant) -> "y",
    Pulmonic(Voiceless, Velar, Plosive) -> "k",
    Pulmonic(Voiced, Velar, Plosive) -> "g",
    Pulmonic(Voiced, Velar, Nasal) -> "ng",
    Pulmonic(Voiced, Velar, Approximant) -> "w",
    Pulmonic(Voiceless, Glottal, Fricative) -> "h"
  )

  val vowels:Map[Vowel, String] = Map[Vowel, String](
    Vowel(Unrounded, Close, Front) -> "ee",
    Vowel(Unrounded, NearClose, NearFront) -> "i",
    Vowel(Unrounded, CloseMid, Front) -> "ay",
    Vowel(Unrounded, OpenMid, Front) -> "e",
    Vowel(Unrounded, NearOpen, Front) -> "a",
    Vowel(Unrounded, Open, Back) -> "o",
    Vowel(Rounded, CloseMid, Back) -> "ow",
    Vowel(Rounded, NearClose, NearBack) -> "oo",
    Vowel(Rounded, Close, Back) -> "ew",
    Vowel(Unrounded, OpenMid, Back) -> "u",
    Vowel(Unrounded, Mid, Central) -> "u"
  )

  trait Instances {
    implicit val usEnglishTranscription:Transcription =
      Transcription(pulmonics) |+| Transcription(vowels)
  }
  object instances extends Instances
}
import USEnglish.instances._
```

## Transcribe the phonology

Now with all the bookkeeping out of the way, lets see what we have. First, we'll
generate an alphabet (of sorts), which simply transcribes each `Phone` in our
`Prosody` using the above `Transcription`. Since our `USEnglish` transcription
doesn't provide a mapping for every possible vowel and consonant, the
`Transcription` will transparently use a distance method to find the closest
mapping available. If there is nothing close, it will transcribe the `Phone` as
an underscore (`_`).

```tut
import cats.data.NonEmptyList

println(prosody.phonology.pulmonics.map(p => NonEmptyList.one(p).transcribe).toList.mkString(", "))
println(prosody.phonology.vowels.map(v => NonEmptyList.one(v).transcribe).toList.mkString(", "))
```

## Get some monosyllables from the Prosody

Next, we'll use our `Prosody` to generate some monosyllabic "words".

```tut
val syllableGen = Prosody.syllable(prosody).map(_.transcribe)
syllableGen.pack(20).apply(rng).foreach(println)
```

## Create some two-, three-, and four-syllable words

Building on the above, lets create some multi-syllabic words.

```tut
val syllable2 = syllableGen.pack(2).map(_.mkString)
val syllable3 = syllableGen.pack(3).map(_.mkString)
val syllable4 = syllableGen.pack(4).map(_.mkString)

syllable2.pack(15).apply(rng).foreach(println)
syllable3.pack(10).apply(rng).foreach(println)
syllable4.pack(5).apply(rng).foreach(println)
```

## What's in a name

Now that we can generate "words" of varying length, let's combine them to make
our names. We'll replace the underscores with the more trendy apostrophe and
provide capitalization as well.

```tut
val nameGen = for {
  s1 <- syllableGen.map(_.capitalize)
  s2 <- syllable2.map(_.capitalize)
  s3 <- syllable3.map(_.capitalize)
  s4 <- syllable4.map(_.capitalize)
  s1_2 = List(s1, s2).mkString(" ")
  s2_1 = List(s2, s1).mkString(" ")
  s1_3 = List(s1, s3).mkString(" ")
  name <- Dist.oneOf(s1, s2, s1_2, s2_1, s1_3, s3, s4)
} yield name.map({
  case '_' => '\''
  case x => x
})

nameGen.pack(20).apply(rng).foreach(println)
```
